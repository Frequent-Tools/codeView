C++ 最常见50道面试题

来自：https://blog.csdn.net/BostonRayAlen/article/details/93041395
可以扫微信登录再复制内容。有些问题回答的不好，而且我想要英文回答，所以就把问题复制到Perplexity并要求其用英文回答。

#### C语言的关键字static和C++的关键字static有什么区别
##### In C
static applied to a local variable inside a function means the variable retains its value across function calls and is initialized only once; its lifetime is the entire program, but its scope is limited to the function.  
static applied to a global variable or function gives it internal linkage, so it is visible only within the current source file and cannot be accessed from other files.  
C does not allow static members inside structures or as class members, since it is not object-oriented.

##### In C++
C++ inherits all static keyword behaviors from C (`local static variables`, `file-scope internal linkage` for global symbols).  
Additionally, static can be used in class definitions:  
Static member variables are shared by all objects of the class, rather than each object having its own copy.  
Static member functions belong to the class itself, can be called without an instance, and do not have access to the class's this pointer.
Example of static member variable and static member function:  
```cpp
#include <iostream>
using namespace std;

class Box {
private:
    static int count;  // static data member shared by all objects
public:
    Box() {
        count++;  // increment count when a new object is created
    }
    static void printCount() {  // static member function
        cout << "Number of Box objects: " << count << endl;
    }
};

// Initialize static data member outside the class
int Box::count = 0;

int main() {
    Box b1;
    Box b2;
    // Call static function via class name (preferred)
    Box::printCount();
    // Can also be called via object though less recommended
    b1.printCount();
    return 0;
}
```
#### Ｃ中的malloc和Ｃ++中的new有什么区别

|      |  |       | | |
|:---------|:-----|:-----------|--| - |
| malloc/free  | C  | no call constructor  | returns void *| cannot be overloaded|
| new/delete    | C++  | calls constructor    |returns correct pointer type| can be overloaded| 


The `malloc` function in C and the `new` operator in C++ are both used for dynamic memory allocation, but there are several key differences.  
`malloc` is a function from the C standard library, while new is an operator built into C++.  
`malloc` simply allocates raw memory; it does not call constructors for objects.  
`new` allocates memory and also calls the constructor for object initialization in C++.  
`malloc` returns a void* pointer (generic pointer), so you must cast it to the desired type, but new returns a pointer of the correct type automatically.  
On failure, malloc returns NULL, but new throws a std::bad_alloc exception (unless using nothrow).  
Memory allocated by malloc must be freed with `free`, while memory allocated by new must be released with `delete`.  
`new` and `delete` can be overloaded for custom behavior in C++; `malloc` and `free` cannot.

#### 写一个“标准”宏 MIN
```cpp
#define MIN(a,b) ((a)<=(b)?(a):(b)) 
```
注意：在调用时一定要注意这个宏定义的副作用，如下调用，p 指针就自加了两次，违背了 MIN 的本意。
```cpp
((++*p)<=(x)?(++*p):(x) 
```

#### a 和&a 有什么区别
请写出以下代码的打印结果，主要目的是考察 a 和&a 的区别。
```cpp
#include<stdio.h> 
void main(){
 	int a[5]={1,2,3,4,5}; 
 	int *ptr=(int *)(&a+1); 
 	printf("%d,%d",*(a+1),*(ptr-1));  	
} 
```
输出结果：2，5。
这是因为数组在内存中是连续存储的，a+1表示数组的第2个元素的地址。而ptr是一个指针，它指向的是a整个数组在内存中的后一个位置，也就是数组外的地址。所以*(a+1)等于2，表示取数组内的第2个元素。而*(ptr-1)等于5，表示取了指针指向的地址的前一个位置的元素，也就是数组内的最后一个元素。<br>

#### 简述 C、C++程序编译的内存分配情况
C and C++ memory allocation during compilation and execution can be divided into three main types:

**Static storage allocation:** Memory is allocated at compile time, and this memory persists for the entire duration of the program. This region is fast and less error-prone because the system manages it automatically. **Examples include global variables and variables declared as static.**

**Stack allocation:** Memory is allocated on the stack when a function is called for all local variables within that function. These memory blocks are automatically freed once the function execution ends. Stack allocation is highly efficient due to built-in support from the processor, but the stack size is limited.

**Heap allocation:** This is dynamic memory allocation, **requested at runtime using malloc in C or new in C++.** The lifetime of these memory blocks is determined by the programmer, who must explicitly free the memory using free or delete. Heap memory is flexible but requires careful management to prevent leaks and fragmentation.

At compile time, a typical C or C++ program divides its memory into five major segments: the heap, the stack, the global/static area, the literal/constant area, and the program code area.

#### 设置地址为 0x67a9 的整型变量的值为 0xaa66
```cpp
int *ptr;  
ptr = (int *)0x67a9;  
*ptr = 0xaa66;  
```
无论在什么平台地址长度和整型数据的长度是一样的，即一个整型数据可以强制转换成地址指针类型。

#### 谈谈你对拷贝构造函数和赋值运算符的认识
The copy constructor creates a new class object as a copy of an existing object, while the assignment operator cannot create a new object, it assigns values between already existing objects.  
Since the copy constructor constructs a brand-new object, there is no need to check for self-assignment. In contrast, the assignment operator usually needs to check if the source and destination objects are the same to avoid unnecessary operations. For classes managing dynamic memory, the assignment operator typically must release existing resources before copying new ones to avoid memory leaks.  
It is important to implement both the copy constructor and assignment operator manually if your class contains pointer-type member variables, to prevent shallow copy issues and memory errors.
```cpp
class MyClass {
    int* data;
public:
    // A default constructor needs to be explicitly created if you need it and if you 
    // explicitly created a constructor. 
    MyClass():MyClass(0){}
    MyClass(int v){
        data = new int;
        *data = v;
    }

    // Copy Constructor
    MyClass(const MyClass& other) {
        data = new int(*other.data); // Deep copy
    }

    // Assignment Operator
    MyClass& operator=(const MyClass& other) {
        if (this != &other) { // Self-assignment check
            delete data; // Free old memory
            data = new int(*other.data); // Deep copy
        }
        return *this; //enable assignment chaining
    }

    ~MyClass() {
        delete data;
    }
};

int main(){
    MyClass a(5);
    MyClass b = a; // Calls copy constructor
    MyClass c;
    c = a;         // Calls assignment operator`
    return 0;
}
```
Also in this example, a default constructor is created if it is needed. In C++ if you define any constructor explicitly for a class, the compiler will not automatically generate a default constructor (one with no parameters) for that class.  
In the assignment operator, after the classed is correctly given the value, it still returns *this, that is for assignment chaining. 


#### 访问基类的私有虚函数
**这题目前是我的知识盲区，有时间的话学一学。**<br>
写出以下程序的输出结果：
```cpp
#include <iostream.h> 
class A 
{ 
 	virtual void g() 
 	{ 
 	 	cout << "A::g" << endl; 
 	} 
private: 
 	virtual void f() 
 	{ 
 	 	cout << "A::f" << endl; 
 	} 
}; 
class B : public A 
{ 
 	void g() 
 	{ 
 	 	cout << "B::g" << endl; 
 	} 
 	virtual void h() 
 	{ 
 	 	cout << "B::h" << endl; 
 	} 
}; 
typedef void( *Fun )( void ); void main() 
{ 
 	B b; 
 	Fun pFun; 
 	for(int i = 0 ; i < 3; i++) 
 	{ 
 	 	pFun = ( Fun )*( ( int* ) * ( int* )( &b ) + i ); 
 	 	pFun(); 
 	} 	 
} 
```
输出结果：
B::g
A::f
B::h
注意：本题主要考察了面试者对虚函数的理解程度。一个对虚函数不了解的人很难正确的做出本题。
在学习面向对象的多态性时一定要深刻理解虚函数表的工作原理。

#### 简述类成员函数的重写、重载和隐藏的区别
The differences among class member function overriding, overloading, and hiding can be summarized as follows:

##### Overriding vs Overloading
**Scope difference:** Overriding happens between two classes (base and derived). Overloading happens within the same class.

**Parameters:** Overridden function and overriding function have exactly the same parameter list. Overloaded functions have different parameter lists.

**Virtual keyword:** The base class function that is overridden must be marked virtual. Overloaded functions may or may not be virtual.

##### Hiding vs Overriding/Overloading
**Scope difference:** Like overriding, hiding happens between base and derived classes. Overloading happens within the same class.  
**Parameters:** Hidden function and the function hiding it have the same name but can have the same or different parameter lists. If the parameter lists differ, the base class function is hidden, not overridden, regardless of virtual keyword presence.  
**Additional explanation:** Overloading and overriding both facilitate polymorphism but at different times: Overriding enables runtime polymorphism (dynamic binding). Overloading enables compile-time polymorphism (static binding).  
Hiding is not polymorphism; it simply causes the base class function(s) to be hidden from the derived class scope when functions share the same name.  
This distinction ensures proper function resolution in inheritance hierarchies and helps avoid unintended behavior due to name conflicts.  
Here is an example of function hiding in C++:
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void show() {
        cout << "Base show() called" << endl;
    }
    void show(int x) {
        cout << "Base show(int) called: " << x << endl;
    }
};

class Derived : public Base {
public:
    void show(char c) {
        cout << "Derived show(char) called: " << c << endl;
    }
};

int main() {
    Derived d;
    // d.show();        // Error: Base::show() is hidden by Derived::show(char)
    d.show('A');        // Calls Derived::show(char)
    // d.show(10);      // Error: Base::show(int) is hidden too
    
    // To access Base's show(), use 'using' in Derived or specify scope:
    d.Base::show();     // Calls Base::show()
    d.Base::show(10);   // Calls Base::show(int)
    
    return 0;
}
```
The Derived class defines a show(char) function. This hides all show() functions in Base with the same name, even though their parameter lists differ. Without explicit qualification, calls like d.show() or d.show(10) result in an error because those base class functions are hidden.

#### 简述多态实现的原理
**虚函数表的知识并未学习，需要补习一下。多态方面需要认真学习一下，这是面试的重要内容。**  
The fundamental principle behind implementing polymorphism in C++ involves the use of a virtual function table (vtable) and a virtual pointer (vptr):
* When the compiler detects that a class contains virtual functions, it automatically creates a vtable for that class. The vtable is essentially an array of pointers, each pointing to the respective virtual function implementations.
* Additionally, the compiler inserts a hidden pointer called vptr into each object of that class. This vptr points to the vtable corresponding to that object's class.
* When an object of a class with virtual functions is constructed, the vptr is set to point to the correct vtable, linking the object to its class's virtual functions.
* When a virtual function is called through a base class pointer or reference, the program uses the vptr to look up the correct function pointer in the vtable and calls the actual function implementation corresponding to the object's derived class.
* This mechanism enables dynamic binding or late binding, which means the decision which function to execute is made at runtime, thus supporting polymorphism.  
It is important to distinguish between virtual functions, pure virtual functions, and virtual inheritance, but understanding this vtable and vptr mechanism is a cornerstone in mastering how polymorphism works in C++.
#### C++的引用和C语言的指针有什么区别
The main differences between C++ references and C pointers are as follows:
##### Initialization and Storage:
A reference must be initialized when declared but does not allocate additional storage; it acts as an alias to an existing variable.  
A pointer does not need to be initialized at declaration and requires storage to hold the memory address it points to.
##### Reassignment:
Once a reference is initialized, it cannot be changed to refer to a different object.  
A pointer can be reassigned to point to different objects during its lifetime.
##### Nullability:
References cannot be null; they always refer to a valid object.
Pointers can be null, meaning they may not point to any valid object.
#### Usage Caution:
When references are used as function parameters, it can sometimes cause confusion because the caller cannot tell if the parameter is a normal variable or a reference, which can mistakenly lead to unintended modifications of the passed-in data. Therefore, references should be used carefully as function parameters.  

#### typedef 和 define 有什么区别
The main differences between typedef and #define are:
##### Usage:
typedef is used to create an alias for an existing data type to improve code readability.
#define is primarily used to define constants or macros, often for repeated complex code.
##### Timing of execution:
typedef is handled during the compilation process and supports type checking.
#define is a preprocessor directive processed before compilation and simply performs textual substitution with no type checking.
##### Scope:
typedef respects scope rules like variables (block or file scope).
#define is globally effective from the point of declaration, without scope limitation.
##### Pointer handling:
Defining pointers with typedef and #define differs significantly; typedef defines true type aliases, while #define does simple text replacement which can cause unexpected behavior with pointers.
##### Syntax:
typedef is a statement and requires a semicolon at the end.
#define is not a statement and should not end with a semicolon.

**In summary,** typedef is used for creating type aliases with compiler support, while #define provides simple text replacement without any type safety.

**typedef 和 define 定义指针**  
这一部分是我补充让Perplexity回答的问题。
##### Using typedef to define pointers
typedef is used to create type aliases, which helps to define pointer types more clearly and safely.
```cpp
typedef int* IntPtr;   // IntPtr is a type alias for int*
IntPtr p1, p2;   // Both p1 and p2 are pointers to int
```
This avoids confusion like:
```cpp
int* p1, p2;    // p1 is a pointer to int, but p2 is just an int variable
```
For function pointers, typedef also improves readability:

```cpp
typedef void (*FuncPtr)(int);  // FuncPtr is a pointer to a function taking int and returning void
FuncPtr f = someFunction;
f(10);
```
##### Using define to define pointers
#define can perform simple text replacement but is not type-aware and can lead to unexpected behavior with pointers.
**Example (not recommended):**
```cpp
#define IntPtr int*

IntPtr p1, p2;  // Expands to int* p1, p2; where only p1 is a pointer, p2 is int
```
This can cause bugs because only the first identifier gets the pointer type.

#### 关键字const是什么
The keyword const in C++ is used to define a variable or object as read-only, meaning its value cannot be changed after initialization. The main advantages of using const include:
* Enables type checking by the compiler, helping catch unintended modifications.
* Like macros, it supports easier adjustments and parameter modifications.
* Conserves memory by avoiding unnecessary allocations.
* Allows functions to be overloaded based on const parameters.

When used to modify function parameters, const serves as a programming convention for readability, making it immediately clear that the parameter will not be changed within the function, reducing errors. Additionally, when const is used to qualify member functions, it ensures those functions do not modify the member variables of the class.  
In summary, const improves code safety, clarity, and maintainability by enforcing immutability where appropriate.
#### 流操作符重载为什么返回引用
The reason why stream operators (<< and >>) are overloaded to return a reference (usually a reference to the stream object) is primarily to support chaining of these operators in a seamless and efficient manner. 
```cpp
#include <iostream>
using namespace std;

class MyNumber {
public:
    int value;
    MyNumber(int v = 0) : value(v) {}

    // Overload stream insertion operator <<
    friend ostream& operator<<(ostream& os, const MyNumber& num) {
        os << num.value;
        return os;  // Return reference to the stream for chaining
    }

    // Overload stream extraction operator >>
    friend istream& operator>>(istream& is, MyNumber& num) {
        is >> num.value;
        return is;  // Return reference to the stream for chaining
    }

    // Overload addition operator +
    MyNumber operator+(const MyNumber& other) const {
        return MyNumber(value + other.value);  // Return a new object (by value)
    }
};

int main() {
    MyNumber a, b, c;

    cout << "Enter three numbers: ";
    cin >> a >> b >> c;  // Using >> chaining

    cout << "You entered: " << a << ", " << b << ", " << c << endl;

    MyNumber d = a + b + c;
    cout << "Sum = " << d << endl;

    return 0;
}
```
```commandline
$ ./main
Enter three numbers: 1 2 3
You entered: 1, 2, 3
Sum = 6
```

#### 简述指针常量与常量指针区别
A pointer constant (often called a constant pointer) means the pointer itself is fixed after initialization; its value (the address it holds) cannot be changed later. You must initialize it when you define it, and you cannot make it point to another object afterwards. However, the object it points to can be modified if it is not const.  
A constant pointer that points to a constant object (often called a pointer to constant) means the pointer can change to point to different objects, but the object it points to is read-only through this pointer and cannot be modified via it.
##### The key difference:
Pointer constant (constant pointer) emphasizes that the pointer itself is immutable (cannot point elsewhere).  
Constant pointer (pointer to constant) emphasizes that the pointed-to object is immutable (cannot be modified through the pointer).  
In either case, their main use, especially as function parameters, is to ensure that either the pointer or the data it points to cannot be changed inside the function, protecting the input arguments from accidental modification.  
An example: 
```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 10;
    int b = 20;

    // Constant pointer: pointer value (address) can't change, but pointee can be modified
    int* const ptrConst = &a;
    cout << "ptrConst points to: " << *ptrConst << endl;

    *ptrConst = 15;  // allowed: change value at pointed location
    cout << "After modification, a = " << a << endl;

    // ptrConst = &b;  // ERROR: cannot change address ptrConst points to

    // Pointer to constant: pointer value can change, but pointee can't be modified via this pointer
    const int* ptrToConst = &a;
    cout << "ptrToConst points to: " << *ptrToConst << endl;

    // *ptrToConst = 25;  // ERROR: cannot modify value through pointer to constant

    ptrToConst = &b;    // allowed: pointer can point to another address
    cout << "ptrToConst now points to: " << *ptrToConst << endl;

    return 0;
}
```
#### 数组名和指针的区别
请写出以下代码的打印结果：
```cpp
#include <iostream.h>
#include <string.h>
void main(void)
{
	char str[13]="Hello world!";
	char *pStr="Hello world!";
	cout<<sizeof(str)<<endl;
	cout<<sizeof(pStr)<<endl;
	cout<<strlen(str)<<endl;
	cout<<strlen(pStr)<<endl;
	return;
}
```
【答案】
打印结果：
13
4
12
12
注意：一定要记得数组名并不是真正意义上的指针，它的内涵要比指针丰富的多。但是当数组名当做参数传递给函数后，其失去原来的含义，变作普通的指针。另外要注意 sizeof 不是函数，只是操作符。  
This is a C code, ISO C++ forbids converting a string constant to ‘char*’, the following line is not allowed in C++. 
```cpp
char *pStr="Hello world!";
```
#### 如何避免“野指针”
A "wild pointer" refers to a pointer variable that points to an unpredictable or invalid memory address. This happens mainly due to the following reasons and can be addressed as follows:  
**Pointer declared but not initialized:** The pointer contains a garbage (random) address when declared without initialization.
**Solution:** Always initialize pointers when declaring them, either by assigning a valid address or by setting them to NULL.
**Pointer used after memory is freed or deleted:** After freeing or deleting the memory a pointer refers to, the pointer still holds that now-invalid address.
**Solution:** After freeing/deleting, immediately set the pointer to NULL to avoid dangling references.
**Pointer points to memory beyond variable's scope:** If the pointer points to a local variable that goes out of scope, the pointer becomes invalid.
**Solution:** Before the variable goes out of scope, free or release the memory correctly and set the pointer to NULL.  
In summary, wild pointers can be avoided by initializing pointers, setting them to NULL after memory release, and carefully managing variable lifetimes and memory ownership.
#### 常引用有什么作用
Const references in C++ are mainly introduced to prevent unintentionally modifying the value of a variable when using references. They act as read-only aliases for ordinary variables.  
The main uses of const references are:  
To define a read-only alias for a normal variable.  
As function parameters to avoid accidental changes to the arguments.  
When const references are used as function parameters, the referenced object is effectively treated as a constant inside the function, meaning the argument value cannot be changed. This brings the benefits of better readability and reduced chances of bugs due to unintended modifications.  
In summary, const references allow efficient passing of variables without copying while ensuring the data cannot be modified through the reference, leading to safer and clearer code.
#### 构造函数能否为虚函数
Constructors cannot be virtual functions in C++. The key reasons and rules are:  
During object construction, the derived class parts are not yet initialized when the base class constructor runs. Therefore, if a constructor calls a virtual function, it will call the base class version, not any overridden versions in derived classes. This is because the dynamic type of the object under construction is not yet the derived type.  
Because of this, calling virtual functions inside constructors is not only prohibited from being virtual themselves, but also calling virtual functions from constructors is generally discouraged or can lead to unexpected behavior.  
Destructors, however, can and often should be virtual. Virtual destructors ensure that when deleting an object via a base class pointer, the derived class destructor is called correctly, allowing proper cleanup.  
Additionally, destructors can also be pure virtual, but even pure virtual destructors must have a function body defined because the destructor chain is always called during object destruction.  
The reason virtual functions exist is to enable runtime polymorphism through dynamic binding, which relies on a virtual function table lookup. But this mechanism only applies fully when the object is completely constructed.

#### 看到哪里了
访问基类的私有虚函数, 20250919
